<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>â€Ž</title>
    <style>
    	html, body { margin:0; padding:0; overflow:hidden; background:black; }
    	canvas { display:block; }
    </style>
  </head>
  <body>
  	<canvas id="canvas"></canvas>
  	<div id="text"></div>
  	<script>
  	  // canvas set up
  	  const canvas = document.getElementById("canvas");
  	  const ctx = canvas.getContext("2d"); // polar coordinate system

  	  // screen set up
  	  let windowWidth = canvas.width = window.innerWidth;
	    let windowHeight = canvas.height = window.innerHeight;
	    let screenCenter = { x: windowWidth / 2, y: windowHeight / 2 };

	    // particles collection
      let particles = [];
      let particlesPerFrame = 10;

      // blackhole set up
      let blackHoleSize = 20;
      let exploding = false;
      let explosionProgress = 0;
      let allowInput = true;
      let growthRate = 0.05;

      // Ring set up for input 'O'
      let isRingActive = false;
      let ringRadius = 0;
      let ringSpeed = 5; // Pixels per frame
      let ringWidth = 15; // Width of the consuming ring

      // Properties for explosion
      const roseImg = new Image();
      roseImg.src = "rose.png";
      let roses = [];
      let roseCount = 30;

      // Particle class
      class Particle {
      	constructor(x, y) {
      		if (x !== undefined && y !== undefined) {
            this.spawnAt(x, y);
          } else {
              this.spawn();
          }
          this.life = 10;
        }
      	spawn() {
      	  const angle = Math.random() * Math.PI * 2; // angle in the polar coordinate
      	  const rad = Math.max(windowWidth, windowHeight) * (0.5 + Math.random() * 0.6);
      	  this.x = screenCenter.x + Math.cos(angle) * rad; // convert to x: cartesian
          this.y = screenCenter.y + Math.sin(angle) * rad; // convert to y: cartesian
          this.vx = (Math.random() - 0.5) * 0.8; // velocity x
    	    this.vy = (Math.random() - 0.5) * 0.8; // velocity y
    	    this.size = 1 + Math.random() * 2;
      	}
        spawnAt(x, y) {
          this.x = x;
          this.y = y;
          this.vx = (Math.random() - 0.5) * 0.5;
          this.vy = (Math.random() - 0.5) * 0.5;
          this.size = 1 + Math.random() * 2;
          this.life = 10;
        }
      	update() {
      	  // Calculate distance between the particle and the screen's center
      	  const dx = screenCenter.x - this.x;
   	      const dy = screenCenter.y - this.y;
    	    const disSq = dx * dx + dy * dy;
    	    const dis = Math.sqrt(disSq);

          // Delete when consumed by ring
          if (isRingActive && Math.abs(dis - ringRadius) < ringWidth / 2) {
              this.life = 0;
              return;
          }

    	    // Delete when consumed by blackhole
    	    if (dis < blackHoleSize) {
      	    this.life = 0;
            const growthFactor = 0.002 * this.size;
            blackHoleSize *= 1 + growthFactor;
      	    return;
      	  }

      	  // Black hole's gravity force
      	  const force = (blackHoleSize * 150) / (disSq + 1000);
    	    this.vx += force * (dx / dis);
          this.vy += force * (dy / dis);

          this.vx *= 0.992;
          this.vy *= 0.992;

      	  this.x += this.vx;
          this.y += this.vy; 
      	}
      	draw() {
    	    ctx.beginPath();
          ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
    	    ctx.fillStyle = "rgba(255, 255, 255, 0.5)";
          ctx.fill();
  		  }

      }

    function drawBlackHole() {
  	  ctx.beginPath();
	    ctx.arc(screenCenter.x, screenCenter.y, blackHoleSize, 0, Math.PI * 2);
	    ctx.fillStyle = "black";
      ctx.fill();

      // Blue hues
      ctx.arc(screenCenter.x, screenCenter.y, blackHoleSize, 0, Math.PI * 2);
      ctx.strokeStyle = 'rgba(180, 210, 255, 0.2)';
      ctx.lineWidth = blackHoleSize * 0.02;
      ctx.shadowColor = 'rgba(180, 210, 255, 0.5)';
      ctx.shadowBlur = 15 + blackHoleSize * 0.05;
      ctx.stroke();

      // White glow
      ctx.beginPath();
      ctx.arc(screenCenter.x, screenCenter.y, blackHoleSize, 0, Math.PI * 2);
      ctx.strokeStyle = 'rgba(255, 255, 255, 0.9)';
      ctx.lineWidth = blackHoleSize * 0.01;
      ctx.shadowColor = 'rgba(200, 220, 255, 0.8)';
      ctx.shadowBlur = 10 + blackHoleSize * 0.03;
      ctx.stroke();
      
      ctx.shadowColor = 'transparent';
	  }

    function beginExplode() {
      exploding = true;
      allowInput = false;
      window.removeEventListener("keydown", handleInput);

      // Roses positions
      roses = [];
      for (let i = 0; i < roseCount; i++) {
        roses.push({
          x: Math.random() * windowWidth,
          y: Math.random() * windowHeight,
          angle: Math.random() * Math.PI * 2,
          size: 100 + Math.random() * 40,
        });
      }

    }

    function explodeTrigger() {
      ctx.fillStyle = "rgba(255,255,255,0.15)";
      ctx.fillRect(0,0,windowWidth,windowHeight); 

      roses.forEach(rose => {
        const shakeX = rose.x + (Math.random() - 0.5) * 20;
        const shakeY = rose.y + (Math.random() - 0.5) * 20;
        ctx.drawImage(roseImg, shakeX, shakeY, rose.size, rose.size);
      });

      explosionProgress += 1;
      if (explosionProgress > 100) {
        resetCycle();
      }
    }

    function resetCycle() {
      exploding = false;
      blackHoleSize = 20;
      explosionProgress = 0;
      particles = [];
      allowInput = true;
      window.addEventListener("keydown", handleInput);
    }

    function drawDarkRing() {
      ctx.beginPath();
      ctx.arc(screenCenter.x, screenCenter.y, ringRadius, 0, Math.PI * 2);
      ctx.strokeStyle = "black"; 
      ctx.lineWidth = ringWidth;
      ctx.stroke();
    }

    const charShape = {
      A: [[{x:-0.3,y:0.5},{x:0,y:-0.5}], [{x:0,y:-0.5},{x:0.3,y:0.5}], [{x:-0.15,y:0},{x:0.15,y:0}]],
      B: [[{x:-0.3,y:-0.5},{x:-0.3,y:0.5}], [{x:-0.3,y:-0.5},{x:0.15,y:-0.35}], [{x:0.15,y:-0.35},{x:-0.3,y:0}], [{x:-0.3,y:0},{x:0.15,y:0.35}], [{x:0.15,y:0.35},{x:-0.3,y:0.5}]],
      C: [[{x:0.3,y:-0.5},{x:-0.3,y:-0.5}], [{x:-0.3,y:-0.5},{x:-0.3,y:0.5}], [{x:-0.3,y:0.5},{x:0.3,y:0.5}]],
      D: [[{x:-0.3,y:-0.5},{x:-0.3,y:0.5}], [{x:-0.3,y:-0.5},{x:0.2,y:0}], [{x:0.2,y:0},{x:-0.3,y:0.5}]],
      E: [[{x:0.3,y:-0.5},{x:-0.3,y:-0.5}], [{x:-0.3,y:-0.5},{x:-0.3,y:0.5}], [{x:-0.3,y:0},{x:0.1,y:0}], [{x:-0.3,y:0.5},{x:0.3,y:0.5}]],
      F: [[{x:-0.3,y:-0.5},{x:-0.3,y:0.5}], [{x:-0.3,y:0},{x:0.1,y:0}], [{x:-0.3,y:-0.5},{x:0.3,y:-0.5}]],
      G: [[{x:0.3,y:-0.5},{x:-0.3,y:-0.5}], [{x:-0.3,y:-0.5},{x:-0.3,y:0.5}], [{x:-0.3,y:0.5},{x:0.3,y:0.5}], [{x:0,y:0},{x:0.3,y:0.5}]],
      H: [[{x:-0.3,y:-0.5},{x:-0.3,y:0.5}], [{x:0.3,y:-0.5},{x:0.3,y:0.5}], [{x:-0.3,y:0},{x:0.3,y:0}]],
      I: [[{x:-0.2,y:-0.5},{x:0.2,y:-0.5}], [{x:0,y:-0.5},{x:0,y:0.5}], [{x:-0.2,y:0.5},{x:0.2,y:0.5}]],
      J: [[{x:0.2,y:-0.5},{x:0.2,y:0.3}], [{x:0.2,y:0.3},{x:0,y:0.5}], [{x:0,y:0.5},{x:-0.2,y:0.3}]],
      K: [[{x:-0.3,y:-0.5},{x:-0.3,y:0.5}], [{x:-0.3,y:0},{x:0.3,y:-0.5}], [{x:-0.3,y:0},{x:0.3,y:0.5}]],
      L: [[{x:-0.3,y:-0.5},{x:-0.3,y:0.5}], [{x:-0.3,y:0.5},{x:0.3,y:0.5}]],
      M: [[{x:-0.3,y:0.5},{x:-0.3,y:-0.5}], [{x:-0.3,y:-0.5},{x:0,y:0}], [{x:0,y:0},{x:0.3,y:-0.5}], [{x:0.3,y:-0.5},{x:0.3,y:0.5}]],
      N: [[{x:-0.3,y:0.5},{x:-0.3,y:-0.5}], [{x:-0.3,y:-0.5},{x:0.3,y:0.5}], [{x:0.3,y:0.5},{x:0.3,y:-0.5}]],
      O: [[{x:-0.3,y:-0.5},{x:0.3,y:-0.5}], [{x:0.3,y:-0.5},{x:0.3,y:0.5}], [{x:0.3,y:0.5},{x:-0.3,y:0.5}], [{x:-0.3,y:0.5},{x:-0.3,y:-0.5}]],
      P: [[{x:-0.3,y:-0.5},{x:-0.3,y:0.5}], [{x:-0.3,y:-0.5},{x:0.2,y:-0.5}], [{x:0.2,y:-0.5},{x:0.2,y:0}], [{x:0.2,y:0},{x:-0.3,y:0}]],
      Q: [[{x:-0.3,y:-0.5},{x:0.3,y:-0.5}], [{x:0.3,y:-0.5},{x:0.3,y:0.5}], [{x:0.3,y:0.5},{x:-0.3,y:0.5}], [{x:-0.3,y:0.5},{x:-0.3,y:-0.5}], [{x:0,y:0},{x:0.3,y:0.5}]],
      R: [[{x:-0.3,y:-0.5},{x:-0.3,y:0.5}], [{x:-0.3,y:-0.5},{x:0.2,y:-0.5}], [{x:0.2,y:-0.5},{x:0.2,y:0}], [{x:0.2,y:0},{x:-0.3,y:0}], [{x:-0.3,y:0},{x:0.3,y:0.5}]],
      S: [[{x:0.3,y:-0.5},{x:-0.3,y:-0.5}], [{x:-0.3,y:-0.5},{x:-0.3,y:0}], [{x:-0.3,y:0},{x:0.3,y:0}], [{x:0.3,y:0},{x:0.3,y:0.5}], [{x:0.3,y:0.5},{x:-0.3,y:0.5}]],
      T: [[{x:-0.3,y:-0.5},{x:0.3,y:-0.5}], [{x:0,y:-0.5},{x:0,y:0.5}]],
      U: [[{x:-0.3,y:-0.5},{x:-0.3,y:0.3}], [{x:-0.3,y:0.3},{x:0.3,y:0.3}], [{x:0.3,y:-0.5},{x:0.3,y:0.3}]],
      V: [[{x:-0.3,y:-0.5},{x:0,y:0.5}], [{x:0,y:0.5},{x:0.3,y:-0.5}]],
      W: [[{x:-0.3,y:-0.5},{x:-0.15,y:0.5}], [{x:-0.15,y:0.5},{x:0.15,y:-0.5}], [{x:0.15,y:-0.5},{x:0.3,y:0.5}]],
      X: [[{x:-0.3,y:-0.5},{x:0.3,y:0.5}], [{x:0.3,y:-0.5},{x:-0.3,y:0.5}]],
      Y: [[{x:-0.3,y:-0.5},{x:0,y:0}], [{x:0.3,y:-0.5},{x:0,y:0}], [{x:0,y:0},{x:0,y:0.5}]],
      Z: [[{x:-0.3,y:-0.5},{x:0.3,y:-0.5}], [{x:0.3,y:-0.5},{x:-0.3,y:0.5}], [{x:-0.3,y:0.5},{x:0.3,y:0.5}]],
      1: [[{x:0,y:-0.5},{x:0,y:0.5}]],
      2: [[{x:-0.3,y:-0.5},{x:0.3,y:-0.5}], [{x:0.3,y:-0.5},{x:0.3,y:0}], [{x:0.3,y:0},{x:-0.3,y:0.5}], [{x:-0.3,y:0.5},{x:0.3,y:0.5}]],
      3: [[{x:-0.3,y:-0.5},{x:0.3,y:-0.5}], [{x:0.3,y:-0.5},{x:0.3,y:0.5}], [{x:0.3,y:0.5},{x:-0.3,y:0}], [{x:-0.3,y:0},{x:0.3,y:0.5}]],
      4: [[{x:-0.3,y:-0.5},{x:-0.3,y:0}], [{x:-0.3,y:0},{x:0.3,y:0}], [{x:0.3,y:-0.5},{x:0.3,y:0.5}]],
      5: [[{x:0.3,y:-0.5},{x:-0.3,y:-0.5}], [{x:-0.3,y:-0.5},{x:-0.3,y:0}], [{x:-0.3,y:0},{x:0.3,y:0}], [{x:0.3,y:0},{x:0.3,y:0.5}],  [{x:0.3,y:0.5},{x:-0.3,y:0.5}]],
      6: [[{x:0.3,y:-0.5},{x:-0.3,y:0}], [{x:-0.3,y:0},{x:-0.3,y:0.5}], [{x:-0.3,y:0.5},{x:0.3,y:0.5}], [{x:0.3,y:0.5},{x:0.3,y:0}],  [{x:0.3,y:0},{x:-0.3,y:0}]],
      7: [[{x:-0.3,y:-0.5},{x:0.3,y:-0.5}], [{x:0.3,y:-0.5},{x:-0.1,y:0.5}]],
      8: [[{x:-0.3,y:-0.5},{x:0.3,y:-0.5}], [{x:0.3,y:-0.5},{x:0.3,y:0.5}], [{x:0.3,y:0.5},{x:-0.3,y:0.5}], [{x:-0.3,y:0.5},{x:-0.3,y:-0.5}],  [{x:-0.3,y:0},{x:0.3,y:0}]],
      9: [[{x:0.3,y:0.5},{x:0.3,y:-0.5}], [{x:0.3,y:-0.5},{x:-0.3,y:-0.5}], [{x:-0.3,y:-0.5},{x:-0.3,y:0}], [{x:-0.3,y:0},{x:0.3,y:0}]]
    };

    function spawnLineParticles(linePoints, x, y, size=60, particlesPerLine=8) {
      linePoints.forEach(([p1, p2]) => {
        const start = {x: x + p1.x*size, y: y + p1.y*size};
        const end = {x: x + p2.x*size, y: y + p2.y*size};
        for (let i=0; i<particlesPerLine; i++) {
          const t = particlesPerLine <=1 ? 0.5 : i/(particlesPerLine-1);
          const px = start.x + (end.x - start.x) * t;
          const py = start.y + (end.y - start.y) * t;
          particles.push(new Particle(px, py));
        }
      });
    }

    function createChar(char) {
      const upper = char.toUpperCase();
      const x = 100 + Math.random()*(windowWidth-200);
      const y = 100 + Math.random()*(windowHeight-200);
      if(charShape[upper]) spawnLineParticles(charShape[upper], x, y, 60);
    }

    const keyActions = new Map([
      ['BACKSPACE', () => blackHoleSize = Math.max(20, blackHoleSize - 8)],
      ['O', activateRing],
      ['0', activateRing],
    ])

    function activateRing() {
      if (!isRingActive) { 
        isRingActive = true;
        ringRadius = blackHoleSize + ringWidth / 2;
      }
    }

    // Key handling
    function handleInput(e) {
      const key = e.key.toUpperCase();
      if(keyActions.get(key)) keyActions.get(key)();
      else if(key.length === 1) createChar(key);
      else blackHoleSize *= 1.15;
    }

    window.addEventListener("keydown", handleInput);
    window.addEventListener("resize", () => {
      windowWidth = canvas.width = window.innerWidth;
      windowHeight = canvas.height = window.innerHeight;
      screenCenter = { x: windowWidth / 2, y: windowHeight / 2 };
    });

	  function animate() {
      if (blackHoleSize > Math.max(windowWidth, windowHeight) * 0.7 && !exploding) {
        beginExplode();
      }
      if (!exploding) {
  	  	ctx.fillStyle = "rgba(0,0,0,0.1)"; // slightly transparent to have trails
    		ctx.fillRect(0, 0, windowWidth, windowHeight);

        if (isRingActive) {
          ringRadius += ringSpeed; // Expand the ring
          drawDarkRing();

          // Disappear
          if (ringRadius - ringWidth / 2 > Math.max(windowWidth, windowHeight)) {
            isRingActive = false;
          }
        }

  	  	particles = particles.filter(p => {
      	  p.update();
      	  p.draw();
          return p.life > 0;
    	  });

  	  	// Constantly generate particles
    		for (let i = 0; i < particlesPerFrame; i++) { 
      	  particles.push(new Particle());
    		}

    	  drawBlackHole();

      } else {
        explodeTrigger();
      }
    requestAnimationFrame(animate);
	  }
  
	animate();
  	</script>
  </body>
</html>