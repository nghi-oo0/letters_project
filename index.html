<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>â€Ž</title>
    <style>
    	html, body { margin:0; padding:0; overflow:hidden; background:black; }
    	canvas { display:block; }
    </style>
  </head>
  <body>
  	<canvas id="canvas"></canvas>
  	<div id="text"></div>
  	<script>
  	  // canvas set up
  	  const canvas = document.getElementById("canvas");
  	  const ctx = canvas.getContext("2d"); // polar coordinate system

  	  // screen set up
  	  let windowWidth = canvas.width = window.innerWidth;
	    let windowHeight = canvas.height = window.innerHeight;
	    let screenCenter = { x: windowWidth / 2, y: windowHeight / 2 };

	    // particles collection
      let particles = [];
      let particlesPerFrame = 10;

      // blackhole set up
      let blackHoleSize = 20;
      let exploding = false;
      let explosionProgress = 0;
      let allowInput = true;

      // Particle class
      class Particle {
      	constructor() {
      		this.appear()
      	}
      	appear() {
      	  const angle = Math.random() * Math.PI * 2; // angle in the polar coordinate
      	  const rad = Math.max(windowWidth, windowHeight) * (0.5 + Math.random() * 0.6);
      	  this.x = screenCenter.x + Math.cos(angle) * rad; // convert to x: cartesian
          this.y = screenCenter.y + Math.sin(angle) * rad; // convert to y: cartesian
          this.vx = (Math.random() - 0.5) * 0.8; // velocity x
    	    this.vy = (Math.random() - 0.5) * 0.8; // velocity y
    	    this.size = 1 + Math.random() * 2;
      	}
      	update() {
      	  // Calculate distance between the particle and the screen's center
      	  const dx = screenCenter.x - this.x;
   	      const dy = screenCenter.y - this.y;
    	    const disSq = dx * dx + dy * dy;
    	    const dis = Math.sqrt(disSq);

    	    // Reset the particle when entering the black hole event horizon
          const eventHorizon = blackHoleSize * 1.1;
    	    if (dis < eventHorizon) {
      	    this.appear();
      	    return;
      	  }

      	  // Black hole's gravity force
      	  const force = (blackHoleSize * 150) / (disSq + 1000);
    	    this.vx += force * (dx / dis);
          this.vy += force * (dy / dis);

          // Particles' next fram position
          const nextX = this.x + this.vx;
          const nextY = this.y + this.vy;

          // Next frame vectors
          const new_dx = screenCenter.x - nextX;
          const new_dy = screenCenter.y - nextY;

          // If the current distance is within the threshold, and the new distance is negative, reset
          const closeThreshold = blackHoleSize * 3; // How close to be before checking
          if (dis < closeThreshold && ((dx * new_dx < 0) || (dy * new_dy < 0))) {
              this.appear();
              return;
          }

          // update particle's location
      	  this.x += this.vx;
          this.y += this.vy; 
      	}
      	draw() {
    	    ctx.beginPath();
          ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
    	    ctx.fillStyle = "white";
          ctx.fill();
  		  }

      }

    function drawBlackHole() {
  	  ctx.beginPath();
	    ctx.arc(screenCenter.x, screenCenter.y, blackHoleSize, 0, Math.PI * 2);
	    ctx.fillStyle = "black";
      ctx.fill();
	  }

    function beginExplode() {
      exploding = true;
      allowInput = false;
      window.removeEventListener("keydown", handleInput);
    }

    function explodeTrigger() {
      ctx.fillStyle = "rgba(255,255,255)";
      ctx.fillRect(0,0,windowWidth,windowHeight); 

      explosionProgress += 1;
      if (explosionProgress > 100) {
        resetCycle();
      }
    }

    function resetCycle() {
      exploding = false;
      blackHoleSize = 20;
      explosionProgress = 0;
      particles = [];
      allowInput = true;
      window.addEventListener("keydown", handleInput);
    }

    // Key handling
    function handleInput(e) {
      if (e.key === 'Backspace') {
        blackHoleSize = Math.max(20, blackHoleSize - 8);
      } else if (e.key.length === 1) {
        blackHoleSize += 8;
      }
      if (blackHoleSize > Math.max(windowWidth, windowHeight) * 0.7 && !exploding) {
        beginExplode();
      }
    }

    window.addEventListener("keydown", handleInput);
    window.addEventListener("resize", () => {
      windowWidth = canvas.width = window.innerWidth;
      windowHeight = canvas.height = window.innerHeight;
      screenCenter = { x: windowWidth / 2, y: windowHeight / 2 };

    });

	  function animate() {
      if (!exploding) {
  	  	ctx.fillStyle = "rgba(0,0,0,0.1)"; // slightly transparent to have trails
    		ctx.fillRect(0, 0, windowWidth, windowHeight);

  	  	particles.forEach(p => {
      	  p.update();
      	  p.draw();
    	  });

  	  	// Constantly generate particles
    		for (let i = 0; i < particlesPerFrame; i++) { 
      	  particles.push(new Particle());
    		}

    	  drawBlackHole();

      } else {
        explodeTrigger();
      }
    requestAnimationFrame(animate);
	  }
  
	animate();
  	</script>
  </body>
</html>