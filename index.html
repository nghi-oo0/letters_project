<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>â€Ž</title>
    <style>
    	html, body { margin:0; padding:0; overflow:hidden; background:black; }
    	canvas { display:block; }
    </style>
  </head>
  <body>
  	<canvas id="canvas"></canvas>
  	<div id="text"></div>
  	<script>
  	  // canvas set up
  	  const canvas = document.getElementById("canvas");
  	  const ctx = canvas.getContext("2d"); // polar coordinate system

  	  // screen set up
  	  let windowWidth = canvas.width = window.innerWidth;
	    let windowHeight = canvas.height = window.innerHeight;
	    let screenCenter = { x: windowWidth / 2, y: windowHeight / 2 };

	    // particles collection
      let particles = [];
      let particlesPerFrame = 10;

      // blackhole set up
      let blackHoleSize = 20;
      let exploding = false;
      let explosionProgress = 0;
      let allowInput = true;

      // Ring set up for input 'O'
      let isRingActive = false;
      let ringRadius = 0;
      let ringSpeed = 5; // Pixels per frame
      let ringWidth = 15; // Width of the consuming ring

      // Particle class
      class Particle {
      	constructor(x, y) {
      		if (x !== undefined && y !== undefined) {
            this.spawnAt(x, y);
          } else {
              this.spawn();
          }
          this.life = 10;
        }
      	spawn() {
      	  const angle = Math.random() * Math.PI * 2; // angle in the polar coordinate
      	  const rad = Math.max(windowWidth, windowHeight) * (0.5 + Math.random() * 0.6);
      	  this.x = screenCenter.x + Math.cos(angle) * rad; // convert to x: cartesian
          this.y = screenCenter.y + Math.sin(angle) * rad; // convert to y: cartesian
          this.vx = (Math.random() - 0.5) * 0.8; // velocity x
    	    this.vy = (Math.random() - 0.5) * 0.8; // velocity y
    	    this.size = 1 + Math.random() * 2;
      	}
        spawnAt(x, y) {
          this.x = x;
          this.y = y;
          this.vx = (Math.random() - 0.5) * 0.5;
          this.vy = (Math.random() - 0.5) * 0.5;
          this.size = 1 + Math.random() * 2;
          this.life = 10;
        }
      	update() {
      	  // Calculate distance between the particle and the screen's center
      	  const dx = screenCenter.x - this.x;
   	      const dy = screenCenter.y - this.y;
    	    const disSq = dx * dx + dy * dy;
    	    const dis = Math.sqrt(disSq);

          // Delete when consumed by ring
          if (isRingActive && Math.abs(dis - ringRadius) < ringWidth / 2) {
              this.life = 0;
              return;
          }

    	    // Delete when consumed by blackhole
    	    if (dis < blackHoleSize) {
      	    this.life = 0;
      	    return;
      	  }

      	  // Black hole's gravity force
      	  const force = (blackHoleSize * 150) / (disSq + 1000);
    	    this.vx += force * (dx / dis);
          this.vy += force * (dy / dis);

          this.vx *= 0.992;
          this.vy *= 0.992;

      	  this.x += this.vx;
          this.y += this.vy; 
      	}
      	draw() {
    	    ctx.beginPath();
          ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
    	    ctx.fillStyle = "rgba(255, 255, 255, 0.5)";
          ctx.fill();
  		  }

      }

    function drawBlackHole() {
  	  ctx.beginPath();
	    ctx.arc(screenCenter.x, screenCenter.y, blackHoleSize, 0, Math.PI * 2);
	    ctx.fillStyle = "black";
      ctx.fill();

      // Blue hues
      ctx.arc(screenCenter.x, screenCenter.y, blackHoleSize, 0, Math.PI * 2);
      ctx.strokeStyle = 'rgba(180, 210, 255, 0.2)';
      ctx.lineWidth = blackHoleSize * 0.02;
      ctx.shadowColor = 'rgba(180, 210, 255, 0.5)';
      ctx.shadowBlur = 15 + blackHoleSize * 0.05;
      ctx.stroke();

      // White glow
      ctx.beginPath();
      ctx.arc(screenCenter.x, screenCenter.y, blackHoleSize, 0, Math.PI * 2);
      ctx.strokeStyle = 'rgba(255, 255, 255, 0.9)';
      ctx.lineWidth = blackHoleSize * 0.01;
      ctx.shadowColor = 'rgba(200, 220, 255, 0.8)';
      ctx.shadowBlur = 10 + blackHoleSize * 0.03;
      ctx.stroke();
      
      ctx.shadowColor = 'transparent';
	  }

    function beginExplode() {
      exploding = true;
      allowInput = false;
      window.removeEventListener("keydown", handleInput);
    }

    function explodeTrigger() {
      ctx.fillStyle = "rgba(255,255,255)";
      ctx.fillRect(0,0,windowWidth,windowHeight); 

      explosionProgress += 1;
      if (explosionProgress > 100) {
        resetCycle();
      }
    }

    function resetCycle() {
      exploding = false;
      blackHoleSize = 20;
      explosionProgress = 0;
      particles = [];
      allowInput = true;
      window.addEventListener("keydown", handleInput);
    }

    function drawDarkRing() {
      ctx.beginPath();
      ctx.arc(screenCenter.x, screenCenter.y, ringRadius, 0, Math.PI * 2);
      ctx.strokeStyle = "black"; 
      ctx.lineWidth = ringWidth;
      ctx.stroke();
    }

    function createA() {
      const size = 60;
      const margin = 100;
      const x = margin + Math.random() * (windowWidth - margin * 2);
      const y = margin + Math.random() * (windowHeight - margin * 2);
      const particleCount = 8;

      const top = { x: x, y: y - size / 2 };
      const bottomLeft = { x: x - size / 3, y: y + size / 2 };
      const bottomRight = { x: x + size / 3, y: y + size / 2 };
      const crossLeft = { x: x - size / 6, y: y };
      const crossRight = { x: x + size / 6, y: y };

      function spawnParticlesOnLine(p1, p2, count) {
        for (let i = 0; i < count; i++) {
          const t = count <= 1 ? 0.5 : i / (count - 1);
          const px = p1.x + (p2.x - p1.x) * t;
          const py = p1.y + (p2.y - p1.y) * t;
          particles.push(new Particle(px, py));
        }
      }
      spawnParticlesOnLine(top, bottomLeft, particleCount);
      spawnParticlesOnLine(top, bottomRight, particleCount);
      spawnParticlesOnLine(crossLeft, crossRight, Math.floor(particleCount / 2));
    }

    // Key handling
    function handleInput(e) {
      if (e.key === 'Backspace') {
        blackHoleSize = Math.max(20, blackHoleSize - 8);
      } else if (e.key === 'a' || e.key === 'A') {
          createA();
      } else if (e.key === 'o' || e.key === 'O') {
          if (!isRingActive) { 
            isRingActive = true;
            ringRadius = blackHoleSize + ringWidth / 2;
          }
      }
        else if (e.key.length === 1) {
          blackHoleSize += 8;
      }
      if (blackHoleSize > Math.max(windowWidth, windowHeight) * 0.7 && !exploding) {
        beginExplode();
      }
    }

    window.addEventListener("keydown", handleInput);
    window.addEventListener("resize", () => {
      windowWidth = canvas.width = window.innerWidth;
      windowHeight = canvas.height = window.innerHeight;
      screenCenter = { x: windowWidth / 2, y: windowHeight / 2 };
    });

	  function animate() {
      if (!exploding) {
  	  	ctx.fillStyle = "rgba(0,0,0,0.1)"; // slightly transparent to have trails
    		ctx.fillRect(0, 0, windowWidth, windowHeight);

        if (isRingActive) {
          ringRadius += ringSpeed; // Expand the ring
          drawDarkRing();

          // Disappear
          if (ringRadius - ringWidth / 2 > Math.max(windowWidth, windowHeight)) {
            isRingActive = false;
          }
        }

  	  	particles = particles.filter(p => {
      	  p.update();
      	  p.draw();
          return p.life > 0;
    	  });

  	  	// Constantly generate particles
    		for (let i = 0; i < particlesPerFrame; i++) { 
      	  particles.push(new Particle());
    		}

    	  drawBlackHole();

      } else {
        explodeTrigger();
      }
    requestAnimationFrame(animate);
	  }
  
	animate();
  	</script>
  </body>
</html>